"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lumen_config_1 = __importDefault(require("@digitalnative/lumen-config"));
const ethers_1 = require("ethers");
const vaultFactory_1 = require("./abis/vaultFactory");
const vaultManager_1 = require("./abis/vaultManager");
const vault_1 = require("./abis/vault");
const erc20_2 = require("./abis/erc20");
const api_1 = require("./api");
const runHunter = (dir) => __awaiter(void 0, void 0, void 0, function* () {
    const config = lumen_config_1.default.default({ dir });
    const { events } = config;
    events.emit("hunt:start");
    // register setTimeout to execute in every minute
    yield loop(config, events);
    events.emit("hunt:init");
});
exports.default = runHunter;
function loop(config, events) {
    return __awaiter(this, void 0, void 0, function* () {
        setTimeout(function () {
            return __awaiter(this, void 0, void 0, function* () {
                events.emit("hunt:next");
                yield hunt(config, events);
                loop(config, events);
            });
        }, 1000);
    });
}
function hunt(config, events) {
    return __awaiter(this, void 0, void 0, function* () {
        for (let i = 0; i < config.ethRpc.length; i++) {
            const link = config.ethRpc[i];
            events.emit("hunt:networkChange", { link });
            const api = yield api_1.ethersApi(link, config.private);
            yield huntNetwork(api, config.factory[i], events);
        }
    });
}
function huntNetwork(api, factory, events) {
    return __awaiter(this, void 0, void 0, function* () {
        const vaultFactory = new ethers_1.Contract(factory, vaultFactory_1.vaultFactoryABI, api);
        // get total number of vaults
        const vaults = yield vaultFactory.allVaultsLength();
        const vaultManagerAddr = yield vaultFactory.manager();
        const vaultManager = new ethers_1.Contract(vaultManagerAddr, vaultManager_1.vaultManagerABI, api);
        events.emit("hunt:scan", { vaults });
        const serial = Array.from({ length: vaults.toNumber() }, (v, i) => i).reverse();
        for (let i of serial) {
            try {
                yield investigate(i, vaultManager, vaultFactory, api, events);
            }
            catch (e) {
                console.log(e);
            }
        }
        //events("hunt:results"); 
    });
}
function investigate(i, vaultManager, vaultFactory, api, events) {
    return __awaiter(this, void 0, void 0, function* () {
        // get vault address from factory
        let vaultAddr = yield vaultFactory.getVault(i);
        // check if the contract has been self destruct
        const selfDestruct = yield api.provider.getCode(vaultAddr);
        if (selfDestruct === "0x") {
            return;
        }
        const vault = new ethers_1.Contract(vaultAddr, vault_1.vaultABI, api);
        // get info from vault
        let collateral = yield vault.collateral();
        let debt = yield vault.debt();
        const erc20_1 = new ethers_1.Contract(collateral, erc20_2.erc20ABI, api);
        let [mcr, lfr, sfr, cDecimals, on] = yield vaultManager.getCDPConfig(collateral);
        let cAmount = yield erc20_1.attach(collateral).balanceOf(vaultAddr);
        let dAmount = yield vault.borrow();
        // get whether the position is valid
        const isValidCDP = yield vaultManager.isValidCDP(collateral, debt, cAmount, dAmount);
        // Get health check 
        const HP = yield getHealthCheck(collateral, debt, cAmount, dAmount, vaultManager, mcr);
        const status = getHPStatus(HP);
        // emit each vault status
        events.emit("hunt:vault", {
            i,
            vaultAddr,
            collateral,
            debt,
            cAmount,
            dAmount,
            mcr,
            lfr,
            sfr,
            on,
            isValidCDP,
            status,
            HP
        });
        // check vault health and react
        if (isValidCDP) {
            events.emit("hunt:vaultSafe");
        }
        else if (cAmount == 0) {
            events.emit("hunt:vaultLiquidated");
        }
        else {
            events.emit("hunt:vaultFail");
            // initiate liquidation tx
            try {
                events.emit("hunt:liquidate");
                let liquidate = yield vault.liquidate();
                yield liquidate.wait();
                events.emit("hunt:liquidateSuccess", {});
            }
            catch (e) {
                events.emit("hunt:fail", { e });
            }
        }
    });
}
function getHealthCheck(collateral, debt, cAmount, dAmount, vaultManager, mcr) {
    return __awaiter(this, void 0, void 0, function* () {
        const cPrice = yield vaultManager.getAssetPrice(collateral);
        const dPrice = yield vaultManager.getAssetPrice(debt);
        const dValue = dPrice.mul(dAmount).gt(0) ? dPrice.mul(dAmount) : 1;
        const cdpRatioPercent = cPrice.mul(cAmount).div(dValue) * 100;
        // HP = (MCR + 50%) - (cdpRatio in percentage - mcr)
        const HP = 100 * (cdpRatioPercent - (mcr / 100000)) / 50;
        return HP;
    });
}
function getHPStatus(HP) {
    if (HP <= 0) {
        return 'ðŸ’€';
    }
    else if (HP <= 30) {
        return 'ðŸš‘';
    }
    else if (HP <= 50) {
        return 'ðŸ–¤';
    }
    else if (HP <= 80) {
        return 'ðŸ’›';
    }
    else if (HP <= 100) {
        return 'ðŸ’–';
    }
    else if (HP > 100) {
        return 'ðŸ’Ž';
    }
}
